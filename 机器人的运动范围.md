class Solution {
    int counts = 0;
    public int movingCount(int m, int n, int k) {//主函数，返回能到达的格子数counts
        int[][] visited = new int[m][n]; //定义数组，记录是否访问过，避免重复
        helper(visited, 0, 0, m - 1, n - 1, k);//深度优先搜索，记录能到达的格子数
        return counts;//返回能到达的格子数
    }
    private void helper(int[][] visited, int i, int j, int m, int n, int k){//深度优先搜索函数
        if(i >=0 && j >= 0 && i <= m &&j <= n && visited[i][j] != 1 && (indexSum(i) + indexSum(j)) <= k){//坐标在方格内且没有访问过，
            counts++;     //到达的格子数+1                                                                               //并且坐标数的和<=k
            visited[i][j] = 1;//并标记已访问
            helper(visited, i - 1, j, m, n, k);//搜索左边格子
            helper(visited, i + 1, j, m, n, k);//搜索右边格子
            helper(visited,i, j - 1, m, n, k);//搜索上边格子
            helper(visited,i, j + 1, m, n, k);//搜索下边格子
        }
    }
    private int indexSum(int index){//求坐标数之和的函数
        int sum = index % 10;//得到个位数
        int temp = index / 10;//得到十位数（删去个位数）
        while(temp > 0){ //数字大于零
            sum += temp % 10;  //把数字的%得的每一位相加
            temp /= 10;      //删去个位数（数字减少一位）直到剩下一位数，得0，循环停止
        }
        return sum;//返回坐标和
    }
}
![image](https://github.com/Algorithm-qiu/LeetCode/blob/Algorithm-qiu-patch-image/6B4E86CA-C529-4f3b-9EF7-4EC3DE73E69B.png)
![image](https://github.com/Algorithm-qiu/LeetCode/blob/Algorithm-qiu-patch-image/980AC508-506F-41ab-8FC3-A6D4C189B5DB.png)
